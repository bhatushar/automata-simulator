{"version":3,"sources":["ui/Navbar.tsx","Colors.ts","automatons/Automata.ts","automatons/DFA.ts","automatons/NFA.ts","automatons/TuringMachine.ts","ui/Sidebar.tsx","ui/Canvas.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Navbar","automata","changeAutomata","key","props","onAutomataChange","className","href","this","map","activeAutomata","onClick","id","Component","Colors","Object","freeze","Automata","data","initialState","states","acceptedStates","state_re","statesArray","split","filter","q","test","Set","has","graphData","nodeDataArray","linkDataArray","forEach","node","color","state","acceptedState","push","DFA","transitions","transition_re","t_str","matches","match","currentState","input","nextState","i","from","to","label","link","separator","result","input_arr","walked","path","state_i","index","length","undefined","newGraph","getGraphData","NFA","transitions_re","RegExp","nextStates","trim","qNext","acceptedNode","stateSet","orderQueue","Queue","T","InvertedTree","getRoot","x","z","add","NULL","existsUpward","pop","childState","last_i","input_i","p","front","rear","object","next","root","parent","temp","TuringMachine","MOVE_LEFT","MOVE_RIGHT","BLANK","output","direction","unshift","join","Sidebar","buildAutomata","event","preventDefault","automataData","automataType","onAutomataBuild","runAutomata","tapeTag","onAutomataRun","tape","getTransitionFormat","format","toggleTape","tag","setState","handleStatesChange","currentTarget","value","handleAcceptedStatesChange","handleTransitionsChange","handleTapeChange","TapeTag","onSubmit","htmlFor","placeholder","onChange","type","automataResult","Fragment","$","go","make","Canvas","createDiagram","diagram","WheelZoom","model","linkKeyProperty","layout","allowDelete","allowCopy","nodeTemplate","stroke","nodeBorder","strokeWidth","margin","text","font","linkTemplate","toArrow","scale","fill","linkLabelBackground","curve","Bezier","toShortLength","adjusting","Stretch","reshapable","initDiagram","divClassName","skipsDiagramUpdate","onModelChange","defaultState","App","handleAutomataChange","updatedState","handleAutomataBuild","handleAutomataRun","run","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3a7874cc.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./css/navbar.css\";\r\nimport { AutomataType } from \"../Interfaces\";\r\n\r\ninterface NavbarProps {\r\n    /**\r\n     * This method is called when user changes the automata from the navbar.\r\n     *\r\n     * @param automataType Automata which the user clicked on\r\n     */\r\n    onAutomataChange: (automataType: AutomataType) => void;\r\n    /**\r\n     * Keeps track of which automata is currently running.\r\n     */\r\n    activeAutomata: AutomataType\r\n}\r\n\r\n/**\r\n * It contains the list of automaton and can be used to switch between them.\r\n *\r\n * @props NavbarProps\r\n */\r\nclass Navbar extends Component<NavbarProps> {\r\n    private automata: AutomataType[] = [\"DFA\", \"NFA\", \"Turing Machine\"];\r\n\r\n    render() {\r\n        return (\r\n            <nav className=\"navbar\">\r\n                {/* Navbar title */}\r\n                <a href=\"/\" className=\"navbar-brand\">Automata Simulator</a>\r\n                <div className=\"navbar-list\">\r\n                    { this.automata.map(automata =>\r\n                        <button key={ automata }\r\n                            className={ (this.props.activeAutomata === automata) ? \"navbar-item active\" : \"navbar-item\"}\r\n                            onClick={ () => { this.changeAutomata(automata) } }>\r\n                            { automata }\r\n                        </button>\r\n                    ) }\r\n                </div>\r\n                \r\n                <div id=\"github\">\r\n                    <a href=\"https://github.com/bhatushar/automata-simulator\"\r\n                        className=\"navbar-item\">\r\n                        GitHub Repository\r\n                    </a>\r\n                </div>\r\n            </nav>\r\n        );\r\n    }\r\n\r\n    private changeAutomata = (key: AutomataType) =>\r\n        this.props.onAutomataChange(key);\r\n}\r\n\r\nexport default Navbar;\r\n","// This file contains a single object which is used in different modules.\r\n\r\n/**\r\n * The Colors object is an immutable constant which contains the color property for different graph elements.\r\n *  1. state: Default background color of a state/node\r\n *  2. initialState: Background color for the initial state\r\n *  3. acceptedState: Background color for the accepted/final states\r\n *  4. nodeBorder: Border/stroke color of a node\r\n *  5. link: Default color of a link between two nodes\r\n *  6. linkLabelBackground: Background color for the label on a link, it is set to be same as the document background\r\n *  7. text: Color for any text in the graph\r\n *  8. walked: This is attributes to nodes and links which were accessed while running the automata\r\n */\r\nexport const Colors = Object.freeze({\r\n  \"state\": \"#a83420\",\r\n  \"initialState\": \"#380000\",\r\n  \"acceptedState\": \"#076e00\",\r\n  \"nodeBorder\": \"#2d92ba\",\r\n  \"link\": \"#D3D3D3\",\r\n  \"linkLabelBackground\": \"#20201F\",\r\n  \"text\": \"#ffffff\",\r\n  \"walked\": \"#1d53ff\",\r\n});","import {GraphData} from \"../Interfaces\";\r\nimport {Colors} from \"../Colors\";\r\n\r\n/**\r\n * It is a parent class for different automaton. It should not be instantiated.\r\n * It is extended by different automata classes, and provides common attributes.\r\n */\r\nexport class Automata {\r\n    /**\r\n     * It is the state from which the automata starts its processing.\r\n     */\r\n    protected readonly initialState: string;\r\n    /**\r\n     * A set of all the states of the automata.\r\n     * Using a set for faster access during automata execution.\r\n     */\r\n    protected readonly states: Set<string>;\r\n    /**\r\n     * Set of all accepted states of the automata. It's a subset of states set.\r\n     * Using a set for faster access during automata execution.\r\n     */\r\n    protected readonly acceptedStates: Set<string>;\r\n\r\n    /**\r\n     * Initializes states, acceptedStates and initialState values.\r\n     *\r\n     * @param data It is a subset of AutomataData interface\r\n     */\r\n    constructor(data: { states: string, acceptedStates: string }) {\r\n        // States are alphanumeric\r\n        const state_re = /^[a-zA-Z0-9]+$/;\r\n        // Create an array of states which pass the regex test\r\n        const statesArray = data.states.split('\\n').filter(q => state_re.test(q));\r\n        // First state in the list is the initial state\r\n        this.initialState = statesArray[0];\r\n        // Extracting list of states and storing unique states\r\n        this.states = new Set<string>(statesArray);\r\n        // Extracting accepted states, only keep those ones which are present in \"states\" set.\r\n        this.acceptedStates = new Set<string>(data.acceptedStates\r\n            .split('\\n')\r\n            .filter(q => this.states.has(q)));\r\n    }\r\n\r\n    /**\r\n     * Creates a GraphData object which will be used by Canvas module to  create the respective transition diagram.\r\n     * Only initializes the graph nodes with the states. Since this is common for all automaton, it is implemented here.\r\n     * The initialization of graph links depends on the transition function and, thus, is left up to individual automata.\r\n     * TODO avoid repeated evaluation because the same data is returned every time (same for children methods)\r\n     *\r\n     * @return GraphData Graph initialized with the nodes\r\n     */\r\n    protected getGraphData(): GraphData {\r\n        const graphData: GraphData = { nodeDataArray: [], linkDataArray: [] };\r\n\r\n        this.states.forEach(q => {\r\n            const node = { key: q, color: Colors.state };\r\n            // Set appropriate color\r\n            if (q === this.initialState) node.color = Colors.initialState;\r\n            // Priority given to accepted state color\r\n            if (this.acceptedStates.has(q)) node.color = Colors.acceptedState;\r\n            graphData.nodeDataArray.push(node);\r\n        });\r\n\r\n        return graphData;\r\n    }\r\n}","import { AutomataAPI, AutomataData, GraphData } from \"../Interfaces\";\r\nimport { Colors } from \"../Colors\";\r\nimport { Automata } from \"./Automata\";\r\n\r\n/**\r\n * Transition function: T(currentState, input) = nextState.\r\n * The object can be accessed as: T[\"currentState\"][\"input\"] = \"nextState\"\r\n */\r\ninterface DFATransition {\r\n    [state: string]: { [input: string]: string }\r\n}\r\n\r\n/**\r\n * Deterministic Finite Automata\r\n * Formal definition: M = (Q, E, t, q, F)\r\n * where, Q is a finite set of states\r\n *        E is a finite set of input alphabet\r\n *        t is a transition function\r\n *        q is the initial state\r\n *        F is a subset of Q, a set of accepted states\r\n * t: (Q x E) -> Q\r\n */\r\nexport class DFA extends Automata implements AutomataAPI {\r\n    private readonly transitions: DFATransition;\r\n\r\n    public constructor(data: AutomataData) {\r\n        super(data);\r\n\r\n        // Regex to parse a transition; format: currentState, input = nextState\r\n        // The whitespaces are ignored\r\n        const transition_re = /^\\s*([a-zA-Z0-9]+)\\s*,\\s*([a-zA-Z0-9]+)\\s*=\\s*([a-zA-Z0-9]+)\\s*$/;\r\n\r\n        this.transitions = {};\r\n        // Initializing transitions with the list of states\r\n        this.states.forEach(q => this.transitions[q] = {});\r\n        data.transitions.split('\\n').forEach((t_str: string) => {\r\n            // Iterating over individual transitions\r\n            const matches = t_str.match(transition_re);\r\n            if (matches) {\r\n                // Assigning respective matches\r\n                const currentState = matches[1], input = matches[2], nextState = matches[3];\r\n                if(this.states.has(currentState) && this.states.has(nextState))\r\n                    // Create a transition is the two states are defined\r\n                    this.transitions[currentState][input] = nextState;\r\n            }\r\n        });\r\n    }\r\n\r\n    public getGraphData(): GraphData {\r\n        const graphData = super.getGraphData();\r\n        // Loop over every T[q][i] transition\r\n        for (let q in this.transitions)\r\n            for (let i in this.transitions[q])\r\n                // Add link\r\n                graphData.linkDataArray.push({\r\n                    from: q,\r\n                    to: this.transitions[q][i],\r\n                    label: i,\r\n                    key: `(${q},${i})`, // (q,i)\r\n                    color: Colors.link\r\n                });\r\n        return graphData;\r\n    }\r\n\r\n    /**\r\n     * DFA works by reading an input, checking if a transition exists for the said input from the current state, and\r\n     * making the transition is it exists.\r\n     * Every (q, i) pair has a unique transition.\r\n     *\r\n     * @param input\r\n     * @param separator\r\n     * @return { newGraph: GraphData, result: string }\r\n     */\r\n    public run(input: string, separator: '' | '\\n'): { newGraph: GraphData, result: string } {\r\n        const input_arr = input.split(separator);\r\n        // Contains all the transitions made by DFA\r\n        const walked: DFATransition = {};\r\n        // Contains the ordered path walked by DFA\r\n        let path: string = \"\";\r\n        // state iterator; contains the name of the current state\r\n        let state_i = this.initialState;\r\n        let result: \"Accepted\" | \"Rejected\" | undefined;\r\n\r\n        for (let index = 0; index < input_arr.length; index++) {\r\n            const i = input_arr[index];\r\n            // Define for every state visited\r\n            if (!walked[state_i]) walked[state_i] = {};\r\n            // If transition exists for given input\r\n            if (this.transitions[state_i][i]) {\r\n                walked[state_i][i] = this.transitions[state_i][i];\r\n                path += `(${state_i}, ${i}) = ${walked[state_i][i]}\\n`;\r\n                // Move to next state\r\n                state_i = walked[state_i][i];\r\n            }\r\n            else {\r\n                // No further transitions\r\n                result = \"Rejected\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (result === undefined) {\r\n            // All input symbols were read and processed\r\n            // Input is accepted if last state is an accepted state\r\n            result = this.acceptedStates.has(state_i) ? \"Accepted\" : \"Rejected\";\r\n        }\r\n        result += \"\\n\\nPATH WALKED:\\n\" + path;\r\n\r\n        // Update graph to indicate the transitions made\r\n        const newGraph: GraphData = this.getGraphData();\r\n        newGraph.nodeDataArray.forEach(node => {\r\n            if (walked[node.key]) node.color = Colors.walked;\r\n        });\r\n        newGraph.linkDataArray.forEach(link => {\r\n            if (walked[link.from] && walked[link.from][link.label] === link.to)\r\n                link.color = Colors.walked;\r\n        });\r\n\r\n        return { newGraph, result };\r\n    }\r\n}\r\n","import {AutomataAPI, AutomataData, GraphData} from \"../Interfaces\";\r\nimport {Automata} from \"./Automata\";\r\nimport {Colors} from \"../Colors\";\r\n\r\n/**\r\n * Transition function: T(currentState, input) = <nextState, ...>\r\n * The object can be accessed as: T[\"currentState\"][\"input\"] = Set of next states\r\n */\r\ninterface NFATransition {\r\n    [state: string]: { [input: string]: Set<string> }\r\n}\r\n\r\n/**\r\n * Non-deterministic Finite Automata\r\n * Formal definition: M = (Q, E, t, q, F)\r\n * where, Q is a finite set of states\r\n *        E is a finite set of input alphabet\r\n *        t is a transition function\r\n *        q is the initial state\r\n *        F is a subset of Q, a set of accepted states\r\n * t: (Q x {E + NULL}) -> PowerSet(Q)\r\n */\r\nexport class NFA extends Automata implements AutomataAPI {\r\n    /**\r\n     * Used for null-transitions.\r\n     * A null-transition is made when NFA makes a transition without reading any input from the tape.\r\n     */\r\n    private static readonly NULL = \"null\";\r\n    private readonly transitions: NFATransition;\r\n\r\n    constructor(data: AutomataData) {\r\n        super(data);\r\n\r\n        // Format: currentState, input = nextState1 [, nextState2...]\r\n        // Ignores any whitespace\r\n        const transitions_re = new RegExp(\r\n            \"^\\\\s*([a-zA-Z0-9]+)\\\\s*,\" + // Read current state until , (comma)\r\n            \"\\\\s*([a-zA-Z0-9]+)\\\\s*=\" + // Read input until = (equals symbol)\r\n            \"\\\\s*([0-9a-zA-Z]+\" + // There must be at least one next state\r\n            \"(\\\\s*,\\\\s*[0-9a-zA-Z]+)*)\" + // Additional next states are optional and are separated by comma\r\n            \"\\\\s*$\"); // Match until the end of line\r\n\r\n        this.transitions = {};\r\n        // Define transition for every state\r\n        this.states.forEach(q => this.transitions[q] = {});\r\n        data.transitions.split('\\n').forEach(t_str => {\r\n            // Looping over individual transitions\r\n            const matches = t_str.match(transitions_re);\r\n            if (matches) {\r\n                // Assigning respective matches\r\n                const currentState = matches[1], input = matches[2];\r\n                // Check that currentState exists\r\n                if (this.states.has(currentState)) {\r\n                    // Creating an array of next states with trimmed whitespaces.\r\n                    let nextStates = matches[3] // \"q1, q2, q3\"\r\n                        .split(',')  // [\"q1\", \" q2\", \" q3\"]\r\n                        .map(q => q.trim());   // [\"q1\", \"q2\", \"q3\"]\r\n                    // Filtering out valid next states\r\n                    nextStates = nextStates.filter(q => this.states.has(q));\r\n                    this.transitions[currentState][input] = new Set<string>(nextStates);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public getGraphData(): GraphData {\r\n        const graphData = super.getGraphData();\r\n        // Loop over every T[q][i][qNext] transition\r\n        for (let q in this.transitions)\r\n            for (let i in this.transitions[q])\r\n                this.transitions[q][i].forEach(qNext =>\r\n                    // Add link\r\n                    graphData.linkDataArray.push({\r\n                        from: q,\r\n                        to: qNext,\r\n                        label: i,\r\n                        key: `(${q},${i})/${qNext}`, // (q,i)/qNext\r\n                        color: Colors.link\r\n                    })\r\n                );\r\n        return graphData;\r\n    }\r\n\r\n    /**\r\n     * NFA works on non-determinism, meaning that at each state it has an option to either read an input or not. Based\r\n     * on the decision it then decides which corresponding transition to make. If an input was read, the automata moves\r\n     * to the next input otherwise it remains on the same input. If no input was read, the transition made is a\r\n     * null-transition. Because of non-determinism, the NFA can in at multiple states at once.\r\n     * Every (q,i) pair may have multiple transitions.\r\n     *\r\n     * I'm implementing NFA using an InvertedTree and a Queue. In the tree, a child node is reached by making a\r\n     * transition from parent node's state. The queue holds the nodes in the order they should be processed. This\r\n     * approach somewhat similar to the breadth-first search in graphs.\r\n     *\r\n     * @param input\r\n     * @param separator\r\n     */\r\n    public run(input: string, separator: '' | '\\n'): {newGraph: GraphData, result: string} {\r\n        const input_arr = input.split(separator);\r\n        // Contains nodes in the order of evaluation\r\n        const orderQueue = new Queue<TreeNode>();\r\n        // Initializing tree with root node as initialState\r\n        const T = new InvertedTree(this.initialState);\r\n        // node object will hold the element in the front of orderQueue\r\n        let node: TreeNode | undefined = T.getRoot();\r\n        // Contains an accepted state if it can be reached with the given input\r\n        let acceptedNode: TreeNode | undefined;\r\n        // Contains all the states that can be accessed from a given transition (q, i)\r\n        let stateSet: Set<string>;\r\n\r\n        // To start, add the root to the queue\r\n        orderQueue.push(node);\r\n        // Loop until queue is empty or an accepted state is reached\r\n        while ((node = orderQueue.pop()) && acceptedNode === undefined) {\r\n            // Doing this because the function inside forEach loops don't consider node type-safe\r\n            const x: TreeNode = node;\r\n            // Get all states that accessed from a (q, input[i]) transition\r\n            if ((stateSet = this.transitions[x.q][input_arr[x.i]]))\r\n                stateSet.forEach(q => {\r\n                    // Add all transitioning states to the tree with their respective input index\r\n                    const z = T.add(q, x.i + 1, x);\r\n                    // Check if an accepted state is reached\r\n                    // true if the state reached after reading the entire input\r\n                    if (z.i === input_arr.length && this.acceptedStates.has(z.q))\r\n                        acceptedNode = z;\r\n                    else orderQueue.push(z);\r\n                });\r\n            // Get all null transitions from q\r\n            if ((stateSet = this.transitions[x.q][NFA.NULL]))\r\n                stateSet.forEach(q => {\r\n                    /* This is where the InvertedTree really shines.\r\n                       The general idea is that if a node (q, i) exists on a simple path from leaf to root, then the\r\n                       same node cannot be added. The reasoning behind this is that if another (q, i) is found, the\r\n                       result processed by adding this new node will be the same as the one obtained from the original\r\n                       node.\r\n                       In addition to that, removing all duplicates from a simple path eliminates the chances of falling\r\n                       in a null-loop.\r\n                     */\r\n                    if (!T.existsUpward(q, x.i, x)) {\r\n                        // Add the new node if it doesn't already exist\r\n                        // i remains unchanged because nothing was read from the tape\r\n                        const z = T.add(q, x.i, x);\r\n                        // Same condition as before to check if an accepted state is reached\r\n                        if (z.i === input_arr.length && this.acceptedStates.has(z.q))\r\n                            acceptedNode = z;\r\n                        else orderQueue.push(z);\r\n                    }\r\n                });\r\n        }\r\n\r\n        // Construct result\r\n        let result: string;\r\n        const newGraph = this.getGraphData();\r\n\r\n        if (acceptedNode) {\r\n            // Accepted state was reached; get the path\r\n            // acceptedNode will be used as an iterator variable in the loop below\r\n            result = \"Accepted\\n\\nPATH WALKED:\";\r\n            // Records all the transitions that were made to reach the accepted state\r\n            const walked: NFATransition = {};\r\n            // Records the actual, ordered path taken by the NFA\r\n            let path: string = \"\";\r\n            // Holds the value of acceptedNode.q from the last iteration\r\n            let childState: string | undefined;\r\n            // Holds the value of acceptedNode.i from the last iteration\r\n            let last_i: number | undefined;\r\n            // Loop until the root is reached\r\n            do {\r\n                const {q, i} = acceptedNode;\r\n                if(!walked[q]) walked[q] = {};\r\n\r\n                // childState is the state that will be reached from (q, i) transition\r\n                if (childState) {\r\n                    // If i is same in 2 successive iteration, then a null transition was made\r\n                    const input_i = (i === last_i) ? NFA.NULL : input_arr[i];\r\n                    // Record transition\r\n                    if (!walked[q][input_i]) walked[q][input_i] = new Set<string>();\r\n                    walked[q][input_i].add(childState);\r\n                    // Evaluating bottom-up\r\n                    path = `\\n(${q}, ${input_i}) = ${childState}` + path;\r\n                }\r\n                // Update for next iteration\r\n                childState = q;\r\n                last_i = i;\r\n                acceptedNode = acceptedNode.p;\r\n            } while (acceptedNode);\r\n            // Append path to the result so the user can see it\r\n            result += path;\r\n            // Update the graph to indicate the path walked\r\n            newGraph.nodeDataArray.forEach(node => {\r\n                if (walked[node.key]) node.color = Colors.walked;\r\n            });\r\n            newGraph.linkDataArray.forEach(link => {\r\n                if (walked[link.from] && walked[link.from][link.label] && walked[link.from][link.label].has(link.to))\r\n                    link.color = Colors.walked;\r\n            });\r\n        }\r\n        // If input is rejected, the graph will not be changed\r\n        else result = \"Rejected\";\r\n\r\n        return {newGraph, result};\r\n    }\r\n}\r\n\r\n/**\r\n * Self-referential node\r\n * Contains an object attribute of type T, and a next attribute which points to another node of same type.\r\n * Used as queue elements.\r\n */\r\ninterface Node <T> {\r\n    object: T,\r\n    next: Node<T> | undefined\r\n}\r\n\r\n/**\r\n * Custom implementation of linked-list queue because Array.shift() takes O(n) time.\r\n * This implementation has only two operations - push and pop.\r\n */\r\nclass Queue <T> {\r\n    private front: Node<T> | undefined;\r\n    private rear: Node<T> | undefined;\r\n\r\n    public push(object: T) {\r\n        const node: Node<T> = {object, next: undefined};\r\n        if (this.rear) {\r\n            // Queue has already been initialized\r\n            this.rear.next = node;\r\n            this.rear = this.rear.next;\r\n        }\r\n        else\r\n            // Initialize queue\r\n            this.front = this.rear = node;\r\n    }\r\n\r\n    public pop(): T | undefined {\r\n        if (!this.front)\r\n            // Empty queue\r\n            return undefined;\r\n        const node: Node<T> = this.front;\r\n        if (!this.front.next)\r\n            // Only one item left in queue prior to deletion, unset rear pointer\r\n            this.rear = undefined;\r\n        this.front = this.front.next;\r\n        return node.object;\r\n    }\r\n}\r\n\r\n/**\r\n * A node of the InvertedTree object.\r\n * q is the name of the state.\r\n * i is the index of the input which state q might read (q might make a null transition).\r\n * p is the parent of the node, i.e., the state from which q was reached.\r\n */\r\ninterface TreeNode {\r\n    q: string,\r\n    i: number,\r\n    p: TreeNode | undefined\r\n}\r\n\r\n/**\r\n * An rooted inverted tree implementation where the child points to it's parent.\r\n */\r\nclass InvertedTree {\r\n    // Root of the tree, set in constructor\r\n    private readonly root: TreeNode;\r\n\r\n    /**\r\n     * @param q Root/initial state\r\n     */\r\n    constructor(q: string) { this.root = { q, i: 0, p: undefined }; }\r\n\r\n    /**\r\n     * @return TreeNode Root of the tree\r\n     */\r\n    public getRoot(): TreeNode { return this.root; }\r\n\r\n    /**\r\n     * Adds a node to the tree under the given parent\r\n     *\r\n     * @param q Automata state\r\n     * @param i Input index\r\n     * @param parent\r\n     * @return TreeNode Newly added node\r\n     */\r\n    public add(q: string, i: number, parent: TreeNode): TreeNode { return { q, i, p: parent }; }\r\n\r\n    /**\r\n     * Checks if a node with (q, i) exists in the path from, and including, node to the root.\r\n     * @param q Automata state\r\n     * @param i Input index\r\n     * @param node Node to start searching from\r\n     * @return boolean True if a duplicate node is found\r\n     */\r\n    public existsUpward(q: string, i: number, node: TreeNode): boolean {\r\n        let temp: TreeNode | undefined = node;\r\n        /* From leaf to root, i is stored in non-increasing manner since NFA only moves forward on the input tape.\r\n           To increase efficiency, we can stop the search once the value of temp.i changes instead of going all the way\r\n           to the root every time.\r\n         */\r\n        while (temp && temp.i === i) {\r\n            if (temp.q === q) return true;\r\n            temp = temp.p;\r\n        }\r\n        return false;\r\n    }\r\n}","import {Automata} from \"./Automata\";\r\nimport {AutomataAPI, AutomataData, GraphData} from \"../Interfaces\";\r\nimport {Colors} from \"../Colors\";\r\n\r\n/**\r\n * Transition function: T(currentState, input) = (nextState, output, direction)\r\n * The object can be accessed as: T[\"currentState\"][\"input\"] = { nextState, output, direction }\r\n */\r\ninterface TuringMachineTransition {\r\n    [state: string]: {\r\n        [input: string]: {\r\n            nextState: string,\r\n            output: string,\r\n            direction: string\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * One automata to compute them all.\r\n * Formal definition, M = (Q, G, b, E, t, q, F)\r\n * where, Q is a finite set of states\r\n *        G is a finite set of tape alphabet\r\n *        b is a blank symbol, belongs to G\r\n *        E is a finite set of input alphabet, subset of G - {b}\r\n *        t is a transition function\r\n *        q is the initial state\r\n *        F is a subset of Q, a set of accepted states\r\n * t: (Q x G) -> (Q x G x {L, R})\r\n */\r\nexport class TuringMachine extends Automata implements AutomataAPI {\r\n    private readonly transitions: TuringMachineTransition;\r\n    private readonly MOVE_LEFT = \"L\";\r\n    private readonly MOVE_RIGHT = \"R\";\r\n    private readonly BLANK = \"B\";\r\n\r\n    constructor (data: AutomataData) {\r\n        super(data);\r\n        // For states, tape symbol and direction\r\n        const alphanumeric_re = \"([a-zA-Z0-9]+)\";\r\n        // Format: currentState, tapeInput = nextState, tapeOutput, direction\r\n        // Ignores whitespaces\r\n        const transitions_re = \"^\\\\s*\" + alphanumeric_re + // currentState\r\n        \"\\\\s*,\\\\s*\" + alphanumeric_re + // tapeInput\r\n        \"\\\\s*=\\\\s*\" + alphanumeric_re + // nextState\r\n        \"\\\\s*,\\\\s*\" + alphanumeric_re + // tapeOutput\r\n        `\\\\s*,\\\\s*(${this.MOVE_LEFT}|${this.MOVE_RIGHT})` + // left/right\r\n        \"\\\\s*$\";\r\n\r\n        this.transitions = {};\r\n        // Define transition for every state\r\n        this.states.forEach(q => this.transitions[q] = {});\r\n        data.transitions.split('\\n').forEach(t_str => {\r\n            // Iterate over individual transitions\r\n            const matches = t_str.match(transitions_re);\r\n            if (matches) {\r\n                // Assign respective matches\r\n                const currentState = matches[1], input = matches[2],\r\n                    nextState = matches[3], output = matches[4], direction = matches[5];\r\n                if (this.states.has(currentState) && this.states.has(nextState))\r\n                    // Create transition is current and next states exist\r\n                    this.transitions[currentState][input] = {\r\n                        nextState, output, direction\r\n                    }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    public getGraphData(): GraphData {\r\n        const graphData = super.getGraphData();\r\n        // Loop over every T[q][i] transition\r\n        for (let q in this.transitions)\r\n            for (let i in this.transitions[q]) {\r\n                // Add link\r\n                graphData.linkDataArray.push({\r\n                    from: q,\r\n                    to: this.transitions[q][i].nextState,\r\n                    label: `${i}/${this.transitions[q][i].output}, ${this.transitions[q][i].direction}`, // input/output, direction\r\n                    key: `(${q},${i})`, // (q,i)\r\n                    color: Colors.link\r\n                });\r\n            }\r\n        return graphData;\r\n    }\r\n\r\n    /**\r\n     * Turing Machine works the same way as a DFA; by reading an input and making a corresponding transition.\r\n     * In addition to that, Turing Machine can perform two additional operations. It can overwrite the tape input and\r\n     * move the tape header left or right.\r\n     *\r\n     * @param input\r\n     * @param separator\r\n     */\r\n    public run(input: string, separator: '' | '\\n'): {newGraph: GraphData, result: string} {\r\n        const input_arr = input.split(separator);\r\n        // Input iterator\r\n        let i = 0;\r\n        // State iterator\r\n        let state_i = this.initialState;\r\n        // Records all the transitions that were made\r\n        // linkLabel is the same as the label attribute of a linkDataArray element.\r\n        const walked: { [state: string]: { [linkLabel: string]: string } } = {};\r\n        // Records the ordered path\r\n        let path: string = \"\";\r\n\r\n        // Since Turing Machine doesn't have an explicit halting condition, continue as long as a transition can be made\r\n        while (this.transitions[state_i][input_arr[i]]) {\r\n            const {nextState, output, direction} = this.transitions[state_i][input_arr[i]];\r\n            // Record path\r\n            if (!walked[state_i]) walked[state_i] = {};\r\n            const label = `${input_arr[i]}/${output}, ${direction}`;\r\n            walked[state_i][label] = nextState;\r\n            path += `(${state_i}, ${input_arr[i]}) = ${nextState}, ${output}, ${direction}\\n`;\r\n            // Update tape\r\n            input_arr[i] = output;\r\n            // Moving tape header\r\n            if (direction === this.MOVE_LEFT) {\r\n                if (i === 0)\r\n                    // Already at the start of the tape, add a blank symbol at start\r\n                    input_arr.unshift(this.BLANK);\r\n                else\r\n                    // Move one position to the left\r\n                    i--;\r\n            }\r\n            else {\r\n                // Move right\r\n                if (i === input_arr.length - 1)\r\n                    // Already at the end of the tape, append a blank symbol\r\n                    input_arr.push(this.BLANK);\r\n                // Move one position to the right\r\n                i++;\r\n            }\r\n            // Move to the next state\r\n            state_i = nextState;\r\n        }\r\n\r\n        // Record the last state reached\r\n        if (!walked[state_i]) walked[state_i] = {};\r\n\r\n        // Record result\r\n        let result = (this.acceptedStates.has(state_i)) ? \"Accepted\" : \"Rejected\";\r\n        result += \"\\nPATH WALKED:\\n\" + path;\r\n        result += \"\\nTAPE:\\n\" + input_arr.join(separator);\r\n\r\n        // Update graph\r\n        const newGraph = this.getGraphData();\r\n        newGraph.nodeDataArray.forEach(node => {\r\n            if (walked[node.key]) node.color = Colors.walked;\r\n        });\r\n        newGraph.linkDataArray.forEach(link => {\r\n            if (walked[link.from] && walked[link.from][link.label] === link.to)\r\n                link.color = Colors.walked;\r\n        });\r\n\r\n        return {newGraph, result};\r\n    }\r\n}","import React, { Component, FormEvent } from \"react\";\r\nimport {AutomataAPI, AutomataType} from \"../Interfaces\";\r\nimport { DFA } from \"../automatons/DFA\";\r\nimport { NFA } from \"../automatons/NFA\";\r\n// import {PDA} from \"../automatons/PDA\";\r\nimport {TuringMachine} from \"../automatons/TuringMachine\";\r\nimport \"./css/sidebar.css\";\r\n\r\ninterface SidebarState {\r\n    /**\r\n     * Contains all the data attributes which are passed to the automata.\r\n     */\r\n    automataData: {\r\n        /**\r\n         * Automata states, separated by new-line '\\n'.\r\n         */\r\n        states: string,\r\n        /**\r\n         * Accepted states, separated by new-line '\\n'.\r\n         * These states should also be present in \"states\" string.\r\n         */\r\n        acceptedStates: string,\r\n        /**\r\n         * Transitions that can be made by the automata, separated by new-line '\\n'.\r\n         */\r\n        transitions: string,\r\n        /**\r\n         * Input tape, separation depends on tapeTag.\r\n         */\r\n        tape: string\r\n    },\r\n    /**\r\n     * The type of component used to accept tape input from the user.\r\n     * input: Each character is an individual input to the automata.\r\n     * textarea: Each line is an individual input to the automata.\r\n     */\r\n    tapeTag: \"input\" | \"textarea\"\r\n}\r\n\r\ninterface SidebarProps {\r\n    /**\r\n     * Currently active automata.\r\n     * Sidebar uses it to select which class instance is needed to build the automata.\r\n     */\r\n    automataType: AutomataType,\r\n    /**\r\n     * It will be invoked every time the user builds a new automata.\r\n     * That is, it'll be invoked on \"modelInitializer form\" submission.\r\n     *\r\n     * @param AutomataAPI\r\n     */\r\n    onAutomataBuild: (automata: AutomataAPI) => void,\r\n    /**\r\n     * Invoked on \"modelTest form\" submission.\r\n     * It is responsible for testing the tape on the automata.\r\n     *\r\n     * @param tape Input tape\r\n     * @param separator Character on which to split the tape\r\n     */\r\n    onAutomataRun: (tape: string, separator: '' | '\\n') => void,\r\n    /**\r\n     * Contains the output of the automata from the last run.\r\n     */\r\n    automataResult: string\r\n}\r\n\r\n/**\r\n * Contains forms for building automata and testing input. Also displays the result of test.\r\n *\r\n * @props SidebarProps\r\n * @state SidebarState\r\n */\r\nclass Sidebar extends Component<SidebarProps, SidebarState> {\r\n    constructor(props: SidebarProps) {\r\n        super(props);\r\n        // Initializing here because it is used inside render method\r\n        this.state = {\r\n            automataData: {\r\n                states: \"\",\r\n                acceptedStates: \"\",\r\n                transitions: \"\",\r\n                tape: \"\"\r\n            },\r\n            tapeTag: \"input\"\r\n        };\r\n    }\r\n\r\n    render() {\r\n        // Deconstructing for convenience\r\n        const { states, acceptedStates, transitions, tape } = this.state.automataData;\r\n        // React converts CamelCase variables into Components for some reason\r\n        const TapeTag = this.state.tapeTag;\r\n        return (\r\n            <div className=\"sidebar\">\r\n                {/* This form provides input parameters which are used to build the automata */}\r\n                <form id=\"modelInitializer\" onSubmit={this.buildAutomata}>\r\n                    <h1>Create model</h1>\r\n                    {/* List of automata states\r\n                        Each state is entered in a new line\r\n                        The first state will be the initial state\r\n                        */}\r\n                    <label htmlFor=\"states\">States</label>\r\n                    <textarea id=\"states\"\r\n                              value={ states }\r\n                              placeholder=\"States should be alphanumeric (without whitespaces).\r\n                                    Only enter one state per line. The first state will be the initial state.\"\r\n                              onChange={ this.handleStatesChange }/>\r\n                    {/* List of accepted states\r\n                        Each state is entered in a new line\r\n                        Accepted states must be a subset of transition states\r\n                        */}\r\n                    <label htmlFor=\"acceptedStates\">Accepted States</label>\r\n                    <textarea id=\"acceptedStates\"\r\n                              value={ acceptedStates }\r\n                              placeholder=\"Only enter one state per line.\r\n                                    These states should also be mentioned in 'States' input.\"\r\n                              onChange={ this.handleAcceptedStatesChange }/>\r\n                    {/* Transition function\r\n                        Spaces are not stored\r\n                        Transition rules are split by new line\r\n                        */}\r\n                    <label htmlFor=\"transition\">Transition Function</label>\r\n                    <textarea id=\"transition\"\r\n                              value={ transitions }\r\n                              placeholder={ this.getTransitionFormat() }\r\n                              onChange={ this.handleTransitionsChange }/>\r\n                    {/* Submit button */}\r\n                    <input type=\"submit\" id=\"buildBtn\" className=\"btn-primary\" value=\"Build\"/>\r\n                </form>\r\n\r\n                {/* This form provides tape input to the automata for processing */}\r\n                <form id=\"modelTest\" onSubmit={ this.runAutomata }>\r\n                    <h1>Test model</h1>\r\n                    {/* Tape input\r\n                        If it's read using input, each character will be processed independently\r\n                        If it's read using textarea, each line will be processed independently\r\n                        */}\r\n                    <label htmlFor=\"tape\">Tape input</label>\r\n                    <TapeTag type=\"text\"\r\n                             id=\"tape\"\r\n                             value={ tape }\r\n                             onChange={ this.handleTapeChange }/>\r\n                    {/* Button toggles tape between input and textarea */}\r\n                    <button id=\"tapeToggle\" className=\"btn-alt\" onClick={ this.toggleTape }>\r\n                        Switch to { (this.state.tapeTag === \"input\")? \"string\": \"character\"} input\r\n                    </button>\r\n                    {/* Tests the tape */}\r\n                    <input type=\"submit\" id=\"runBtn\" className=\"btn-primary\" value=\"Test\" />\r\n\r\n                    {/*<button title=\"Stop automata mid-execution. Trying to figure it out.\"\r\n                            id=\"resetBtn\" className=\"btn-secondary\"\r\n                            onClick={ this.resetAutomata }\r\n                            disabled={ true }>\r\n                        Reset\r\n                    </button>*/}\r\n                </form>\r\n\r\n                {/* Only show this segment if a result if returned by the automata */}\r\n                { this.props.automataResult &&\r\n                    <section id=\"automataResult\">\r\n                        <h2>Result</h2>\r\n                        <div id=\"resultContainer\">{\r\n                            // Split result on new-line\r\n                            this.props.automataResult.split('\\n').map((i: string, key) => {\r\n                                return <React.Fragment key={key}>{i} <br/></React.Fragment>;\r\n                            })\r\n                        }</div>\r\n                    </section>\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of an automata and passes it to the parent.\r\n     */\r\n    private buildAutomata = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        // Extracting automata related information from state\r\n        const { automataData: data } = this.state;\r\n        // Selecting the automata instance and typecasting the data accordingly\r\n        switch (this.props.automataType) {\r\n            case \"NFA\":\r\n                this.props.onAutomataBuild(new NFA(data));\r\n                break;\r\n            case \"PDA\":\r\n                //this.props.onAutomataBuild(new PDA(data));\r\n                break;\r\n            case \"Turing Machine\":\r\n                this.props.onAutomataBuild(new TuringMachine(data));\r\n                break;\r\n            default:\r\n                this.props.onAutomataBuild(new DFA(data));\r\n                break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Collects the tape input given by user and passes it forward to be processed by the automata.\r\n     *\r\n     * @param event\r\n     */\r\n    private runAutomata = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        const separator = (this.state.tapeTag === \"input\") ? '' : '\\n';\r\n        this.props.onAutomataRun(this.state.automataData.tape, separator);\r\n    };\r\n\r\n    /**\r\n     * Returns the format in which the automata expects the transitions to be.\r\n     *\r\n     * @return string\r\n     */\r\n    private getTransitionFormat = (): string => {\r\n        let format: string = \"\";\r\n        switch (this.props.automataType) {\r\n            case \"DFA\":\r\n                format = \"Current-state, Input = Next-state\";\r\n                break;\r\n            case \"NFA\":\r\n                format = \"Current-state, Input = Next-state [, Next-state ...]\\n\\nUse 'null' for null-transitions.\";\r\n                break;\r\n            case \"PDA\":\r\n                //format = \"Current-state, Input, Stack-top = (Next-state, Stack-replace) \" +\r\n                //    \"[, (Next-state, Stack-replace) ...]\\nZ is the stack start symbol.\";\r\n                break;\r\n            case \"Turing Machine\":\r\n                format = \"Current-state, Input = Next-state, Tape-replace, L/R\\n\\nUse B for blank symbol.\";\r\n                break;\r\n        }\r\n        return format;\r\n    };\r\n\r\n    /**\r\n     * Toggles the component which accepts tape input from the user.\r\n     *\r\n     * @param event\r\n     */\r\n    private toggleTape = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        const tag = (this.state.tapeTag === \"input\") ? \"textarea\" : \"input\";\r\n        this.setState({ tapeTag: tag });\r\n    };\r\n\r\n    // TODO decide what to do with this\r\n    // private resetAutomata = (event: FormEvent) => { event.preventDefault(); };\r\n\r\n    /* Following are just a bunch of onChange listeners for input and textarea components.\r\n       It's really annoying that I can't just collect the form data at the time of submission.\r\n       Instead, I have to manage individual listener, even though they all perform almost similar tasks.\r\n       They just update the state object with the new value.\r\n       This is the \"recommended\" way as per the official docs.\r\n     */\r\n    private handleStatesChange = (event: FormEvent<HTMLTextAreaElement>) => {\r\n        const automataData = this.state.automataData;\r\n        automataData.states = event.currentTarget.value;\r\n        this.setState({ automataData });\r\n    };\r\n\r\n    private handleAcceptedStatesChange = (event: FormEvent<HTMLTextAreaElement>) => {\r\n        const automataData = this.state.automataData;\r\n        automataData.acceptedStates = event.currentTarget.value;\r\n        this.setState({ automataData });\r\n    };\r\n\r\n    private handleTransitionsChange = (event: FormEvent<HTMLTextAreaElement>) => {\r\n        const automataData = this.state.automataData;\r\n        automataData.transitions = event.currentTarget.value;\r\n        this.setState({ automataData });\r\n    };\r\n\r\n    private handleTapeChange = (event: FormEvent<HTMLTextAreaElement> | FormEvent<HTMLInputElement>) => {\r\n        const automataData = this.state.automataData;\r\n        automataData.tape = event.currentTarget.value;\r\n        this.setState({ automataData });\r\n    };\r\n}\r\n\r\n\r\nexport default Sidebar;","import React, { Component } from \"react\";\r\nimport * as go from \"gojs\";\r\nimport { ReactDiagram } from \"gojs-react\";\r\nimport { GraphData } from \"../Interfaces\";\r\nimport { Colors } from \"../Colors\";\r\n\r\n// Aliasing for convenience\r\nconst $ = go.GraphObject.make;\r\n\r\n/**\r\n * This class uses GoJS library to perform all graph related operations.\r\n * It is responsible for drawing and updating the transition diagram.\r\n *\r\n * @props { graphData: GraphData }\r\n */\r\nclass Canvas extends Component<{ graphData: GraphData }> {\r\n    render() {\r\n        return (\r\n            <ReactDiagram initDiagram={ this.createDiagram }\r\n                divClassName=\"\"\r\n                nodeDataArray={ this.props.graphData.nodeDataArray }\r\n                linkDataArray={ this.props.graphData.linkDataArray }\r\n                skipsDiagramUpdate={ false /* Updates the diagram every time graphData changes */ }\r\n                onModelChange={ () => {/* Just here for formality */} } />\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new diagram instance for GoJS and sets the properties for the diagram.\r\n     *\r\n     * @return go.Diagram\r\n     */\r\n    private createDiagram = (): go.Diagram => {\r\n        // Creating a new diagram\r\n        const diagram = $(go.Diagram,\r\n            {\r\n                // Zoom on scroll\r\n                \"toolManager.mouseWheelBehavior\": go.ToolManager.WheelZoom,\r\n                // Setting key which will be used to find a link during automata execution\r\n                model: $(go.GraphLinksModel, { linkKeyProperty: \"key\" })\r\n            }\r\n        );\r\n\r\n        // Sets the initial layout of the diagram\r\n        diagram.layout = new go.ForceDirectedLayout();\r\n        // Disabling direct modification by user\r\n        diagram.allowDelete = false;\r\n        diagram.allowCopy = false;\r\n\r\n        // Designing nodes\r\n        diagram.nodeTemplate = $(go.Node, \"Auto\",\r\n            // Node is a circle\r\n            $(go.Shape, \"Circle\",\r\n                // Setting border color, border width\r\n                { stroke: Colors.nodeBorder, strokeWidth: 7 },\r\n                // Custom background color for nodes\r\n                new go.Binding(\"fill\", \"color\")),\r\n            $(go.TextBlock,\r\n                // Every node contains a label\r\n                { margin: 10, stroke: Colors.text, font: \"16pt sans-serif\" },\r\n                // Dynamically set the label\r\n                new go.Binding(\"text\", \"key\"))\r\n        );\r\n\r\n        // Designing links\r\n        diagram.linkTemplate = $(go.Link,\r\n            // Link color and width\r\n            $(go.Shape, { strokeWidth: 8 },\r\n                // Dynamically set custom link color if the attribute is provided\r\n                new go.Binding(\"stroke\", \"color\")),\r\n            // Arrowhead properties\r\n            $(go.Shape, { toArrow: \"Standard\", stroke: Colors.link, scale: 2 }),\r\n            // The link label\r\n            $(go.Panel, \"Auto\",\r\n                // Label background is same as diagram background\r\n                $(go.Shape, \"Rectangle\", { fill: Colors.linkLabelBackground, stroke: null }),\r\n                // Actual label text\r\n                $(go.TextBlock, { margin: 5, stroke: Colors.text, font: \"16pt sans-serif\" },\r\n                    // Dynamically setting label\r\n                    new go.Binding(\"text\", \"label\"))),\r\n            // Link shape properties\r\n            {\r\n                curve: go.Link.Bezier, // Makes the link curve\r\n                toShortLength: 8, // Line doesn't cover arrow\r\n                adjusting: go.Link.Stretch, // Link persists it's shape\r\n                reshapable: true // Allows reshaping links\r\n            }\r\n        );\r\n\r\n        return diagram;\r\n    };\r\n\r\n}\r\n\r\nexport default Canvas;","import React, { Component } from 'react';\r\nimport { AutomataAPI, AutomataType, GraphData } from \"./Interfaces\";\r\nimport Navbar from \"./ui/Navbar\";\r\nimport Sidebar from \"./ui/Sidebar\";\r\nimport Canvas from \"./ui/Canvas\";\r\n\r\ninterface AppState {\r\n    /**\r\n     * Informs other components of the type of automata being used.\r\n     */\r\n    automataType: AutomataType,\r\n    /**\r\n     * The actual automata model which will define the transition diagram and run the input.\r\n     * It is initialized only after user submits the modelInitializer form in Sidebar component.\r\n     */\r\n    automata: AutomataAPI | undefined,\r\n    /**\r\n     * Contains the data which will be sent to the Canvas component. Canvas will draw the graph based on this data.\r\n     * It is kept in the state object because I want the actual graph to update every time this object is changed.\r\n     */\r\n    graphData: GraphData,\r\n    /**\r\n     * Contains the output of the automata when it's run on an input tape.\r\n     */\r\n    result: string\r\n}\r\n\r\n/**\r\n * Initial/Default property for the state attribute.\r\n */\r\nconst defaultState: AppState = {\r\n    automataType: \"DFA\",\r\n    automata: undefined,\r\n    graphData: { nodeDataArray: [], linkDataArray: [] },\r\n    result: \"\"\r\n};\r\n\r\n/**\r\n * Top most component\r\n *\r\n * @state AppState\r\n */\r\nclass App extends Component<{}, AppState> {\r\n    constructor(props: {}) {\r\n        super(props);\r\n        this.state = defaultState;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <React.Fragment>\r\n                <Navbar onAutomataChange={ this.handleAutomataChange }\r\n                        activeAutomata={ this.state.automataType } />\r\n                <Sidebar automataType={ this.state.automataType }\r\n                    onAutomataBuild={ this.handleAutomataBuild }\r\n                    onAutomataRun={ this.handleAutomataRun }\r\n                    automataResult={ this.state.result } />\r\n                <Canvas graphData={ this.state.graphData } />\r\n            </React.Fragment>\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invoked when the user changes the automata from the navbar.\r\n     * The method updates App's state with the new automata\r\n     *\r\n     * @param automataType\r\n     */\r\n    private handleAutomataChange = (automataType: AutomataType) => {\r\n        // Reset everything\r\n        const updatedState = defaultState;\r\n        // Change the automata type\r\n        updatedState.automataType = automataType;\r\n        this.setState(updatedState);\r\n    };\r\n\r\n    /**\r\n     * Invoked when user submits the modeInitializer form.\r\n     * It updates App's state with the newly built automata and it's respective graph data.\r\n     *\r\n     * @param automata\r\n     */\r\n    private handleAutomataBuild = (automata: AutomataAPI) =>\r\n        this.setState({ automata, graphData: automata.getGraphData() });\r\n\r\n    /**\r\n     * Invoked when user submits modelTest form.\r\n     * Invokes the run method of the automata object, and updates App's state with the result.\r\n     *\r\n     * @param tape\r\n     * @param separator\r\n     */\r\n    private handleAutomataRun = (tape: string, separator: '' | '\\n') => {\r\n        if (this.state.automata) {\r\n            const { newGraph, result } = this.state.automata.run(tape, separator);\r\n            this.setState({ graphData: newGraph, result });\r\n        }\r\n    };\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}